/*
 *    Copyright 2015 West Coast Informatics, LLC
 */
package com.wci.umls.server.jpa.algo.insert;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Properties;
import java.util.Set;
import java.util.UUID;

import javax.persistence.Query;

import com.wci.umls.server.AlgorithmParameter;
import com.wci.umls.server.ValidationResult;
import com.wci.umls.server.helpers.Branch;
import com.wci.umls.server.helpers.ConfigUtility;
import com.wci.umls.server.helpers.SearchResultList;
import com.wci.umls.server.jpa.ValidationResultJpa;
import com.wci.umls.server.jpa.algo.AbstractInsertMaintReleaseAlgorithm;
import com.wci.umls.server.model.content.Atom;
import com.wci.umls.server.model.content.AtomRelationship;
import com.wci.umls.server.model.content.Concept;
import com.wci.umls.server.model.content.ConceptRelationship;

/**
 * In effort to reduce deleted_cuis, create bequeathals to the live parent 
 * or grandparent concept.
 */
public class CreateAncestorBequeathalAlgorithm extends AbstractInsertMaintReleaseAlgorithm {

  /**
   * Instantiates an empty {@link CreateAncestorBequeathalAlgorithm}.
   * @throws Exception if anything goes wrong
   */
  public CreateAncestorBequeathalAlgorithm() throws Exception {
    super();
    setActivityId(UUID.randomUUID().toString());
    setWorkId("CREATEANCESTORBEQUEATH");
    setLastModifiedBy("admin");
  }

  /* see superclass */
  @Override
  public ValidationResult checkPreconditions() throws Exception {

    ValidationResult validationResult = new ValidationResultJpa();

    if (getProject() == null) {
      throw new Exception("Create ancestor bequeath requires a project to be set");
    }

    // Check the input directories

    final String srcFullPath =
        ConfigUtility.getConfigProperties().getProperty("source.data.dir")
            + File.separator + getProcess().getInputPath();

    setSrcDirFile(new File(srcFullPath));
    if (!getSrcDirFile().exists()) {
      throw new Exception("Specified input directory does not exist");
    }

    return validationResult;
  }

  /* see superclass */
  @Override
  public void compute() throws Exception {
    logInfo("Starting " + getName());

    int addedCount = 0;
    
    // No molecular actions will be generated by this algorithm
    setMolecularActionFlag(false);

    try {

      Set<Concept> deletedCuis = new HashSet<>();
      File srcDir = getSrcDirFile();
      File maintDir = new File(srcDir, "maint");
      if (! maintDir.exists()){
        maintDir.mkdir();
      }
      logInfo("maint dir:" + maintDir);
      BufferedWriter out = new BufferedWriter(new FileWriter(new File(maintDir, "bequeathal.ancestor.relationships.src")));
      
      Query query = getEntityManager().createNativeQuery(
          "SELECT   DISTINCT c.id conceptId FROM   concepts c,   "
          + "concepts_atoms ca,   atoms a WHERE   c.terminology = 'NCIMTH'   "
          + "AND c.id != c.terminologyId   AND c.id = ca.concepts_id   AND "
          + "ca.atoms_id = a.id   "
          + "AND a.publishable = FALSE   AND NOT c.id IN ("
          +   "SELECT       DISTINCT c.id conceptId     " 
          +   " FROM       concepts c,       concepts_atoms ca,       atoms a     "
          +   " WHERE       c.terminology = 'NCIMTH'       AND c.id = ca.concepts_id   "
          +   " AND ca.atoms_id = a.id       AND a.publishable = TRUE   )   " 
          +   " AND NOT c.id IN (     "
          +   "   SELECT       DISTINCT c.id conceptId     "
          +   "    FROM       concepts c,       concept_relationships cr     "
          +   "    WHERE       c.terminology = 'NCIMTH'       AND c.id = cr.from_id       "
          +   "    AND cr.relationshipType like 'B%'   )   AND NOT c.id IN (     "
          +   "      SELECT       c.id conceptId     " 
          +   "        FROM       concepts c,       concepts_atoms ca     "
          +   "        WHERE       c.terminology = 'NCIMTH'       "
          +   "        AND c.id = ca.concepts_id       AND ca.concepts_id IN (         "
          +   "      SELECT           ca.concepts_id         FROM           concepts_atoms ca,           atoms a         " 
          +   "        WHERE           ca.atoms_id = a.id           "
          +   "        AND a.terminology IN ('MTH', 'NCIMTH')           " 
          +   "        AND a.termType = 'PN'       )     GROUP BY       ca.concepts_id     "
          +   "        HAVING       COUNT(DISTINCT ca.atoms_id) = 1   )"
          +   " AND NOT c.id IN (   "
          +   "   SELECT  " 
          +   "     ca.concepts_id conceptId  "
          +   "   FROM  "
          +   "     mrcui mr,  "
          +  "      atomjpa_conceptterminologyids ac,  "
          +  "      concepts_atoms ca,  "
          +  "      concepts cpt  "
          + "     WHERE  "
          +  "      mr.cui1 = ac.conceptTerminologyIds  "
          +  "      AND ca.atoms_id = ac.AtomJpa_id  "
          +  "      AND cpt.id = ca.concepts_id  "
          +  "      AND cpt.terminology = 'NCIMTH'  "
          +  "      AND ac.conceptTerminologyIds_KEY = 'NCIMTH'  "
          +  "      AND mr.rel = 'DEL'  )"
        
          
          );
      

      List<Object> list = query.getResultList();
      setSteps(list.size());
      /*List<Object> list = new ArrayList<>();
      list.add(2228275L);
      list.add(2752574L);
      list.add(1048702L);*/
      int index = 1;
      for (final Object entry : list) {
        final Long id = Long.valueOf(entry.toString());
        Concept c = getConcept(id);
        deletedCuis.add(c);
        c.getAtoms().size();
        c.getRelationships().size();
      }
      for (Concept c : deletedCuis) {
        index++;
        List<String> potentialParentBequeathals = new ArrayList<>();
        List<String> potentialGrandparentBequeathals = new ArrayList<>();
        for (Atom atom : c.getAtoms()) {
          Atom a = getAtom(atom.getId());
          for (AtomRelationship ar : a.getInverseRelationships()) {
            if (ar.getRelationshipType().equals("PAR")) {
              Atom parentAtom = ar.getFrom();
              // Find the NCIMTH concept for the parent atom
              SearchResultList srl = findConceptSearchResults(
                  getProject().getTerminology(), getProject().getVersion(),
                  Branch.ROOT, "atoms.id:" + parentAtom.getId(), null);
              if (srl.size()!= 1) {
                continue;
              }
              Long ncimthConceptId = srl.getObjects().get(0).getId();
              Concept ncimthParentConcept = getConcept(ncimthConceptId);
              
              if (noXRRel(c, ncimthParentConcept) && ncimthParentConcept.isPublishable()) {
                StringBuffer sb = new StringBuffer();
                sb.append("").append("|");
                sb.append("C").append("|");
                sb.append(c.getTerminologyId()).append("|");
                sb.append("BBT").append("|").append("|");
                sb.append(ncimthParentConcept.getTerminologyId()).append("|");
                sb.append("NCIMTH|NCIMTH|R|n|N|N|SOURCE_CUI|NCIMTH|SOURCE_CUI|NCIMTH|||").append("\n");
                potentialParentBequeathals.add(sb.toString());
              } else {
                // consider publishable grandparent
                for (AtomRelationship ar2 : parentAtom.getInverseRelationships()) {
                  if (ar2.getRelationshipType().equals("PAR")) {
                    Atom grandparentAtom = ar2.getFrom();
                    // Find the NCIMTH concept for the grandparent atom
                    SearchResultList srl2 = findConceptSearchResults(
                        getProject().getTerminology(), getProject().getVersion(),
                        Branch.ROOT, "atoms.id:" + grandparentAtom.getId(), null);
                    if (srl2.size()!= 1) {
                      continue;
                    }
                    Long ncimthConceptId2 = srl2.getObjects().get(0).getId();
                    Concept ncimthParentConcept2 = getConcept(ncimthConceptId2);
                   
                    if (noXRRel(c, ncimthParentConcept2) && ncimthParentConcept2.isPublishable()) {
                      StringBuffer sb = new StringBuffer();
                      sb.append("").append("|");
                      sb.append("C").append("|");
                      sb.append(c.getTerminologyId()).append("|");
                      sb.append("BBT").append("|").append("|");
                      sb.append(ncimthParentConcept2.getTerminologyId()).append("|");
                      sb.append("NCIMTH|NCIMTH|R|n|N|N|SOURCE_CUI|NCIMTH|SOURCE_CUI|NCIMTH|||").append("\n");
                      potentialGrandparentBequeathals.add(sb.toString());
                    } 
                  }
                }
              }
            }
          }
        }
        // write out a max of two bequeathals, parent bequeathals get precedence over grandparent ones
        if (potentialParentBequeathals.size() >= 2) {
          out.write(potentialParentBequeathals.get(0));
          addedCount++;
          logInfo("[CreateBequeathal parent] " + potentialParentBequeathals.get(0));
          out.write(potentialParentBequeathals.get(1));
          addedCount++;
          logInfo("[CreateBequeathal parent] " + potentialParentBequeathals.get(1));
        } else if (potentialParentBequeathals.size() == 1) {
          out.write(potentialParentBequeathals.get(0));
          addedCount++;
          logInfo("[CreateBequeathal parent] " + potentialParentBequeathals.get(0));
          if (potentialGrandparentBequeathals.size() >= 1) {
            out.write(potentialGrandparentBequeathals.get(0));
            addedCount++;
            logInfo("[CreateBequeathal grandp] " + potentialGrandparentBequeathals.get(0));
          }
        } else if (potentialGrandparentBequeathals.size() >= 1) {
          out.write(potentialGrandparentBequeathals.get(0));
          addedCount++;
          logInfo("[CreateBequeathal grandp] " + potentialGrandparentBequeathals.get(0));
        }
        updateProgress();
        if (index % 100 == 0) {
          out.flush();
        }
      }
      
      out.close();


      commitClearBegin();

      logInfo("  added count = " + addedCount);

      logInfo("Finished " + getName());

    } catch (

    Exception e) {
      logError("Unexpected problem - " + e.getMessage());
      throw e;
    }

  }

  private boolean noXRRel(Concept a, Concept b) {
    for (ConceptRelationship cr : a.getRelationships()) {
      if (cr.getRelationshipType().equals("XR") && (cr.getFrom().getId() == b.getId() || cr.getTo().getId() == b.getId())) {
          System.out.println("found XR rel: " + a.getId() + " " + b.getId());
          return false;
      }
    }
    return true;
  }
  
  /* see superclass */
  @Override
  public void reset() throws Exception {
    logInfo("Starting RESET " + getName());
    // n/a - No reset
    logInfo("Finished RESET " + getName());
  }

  /* see superclass */
  @Override
  public void checkProperties(Properties p) throws Exception {
    // n/a
  }

  /* see superclass */
  @Override
  public void setProperties(Properties p) throws Exception {
    // n/a
  }

  /* see superclass */
  @Override
  public List<AlgorithmParameter> getParameters() throws Exception {
    final List<AlgorithmParameter> params = super.getParameters();

    return params;
  }

  @Override
  public String getDescription() {
    return "Bequeaths deleted cuis to their closest published ancestor";
  }

}