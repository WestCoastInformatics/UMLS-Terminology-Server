/*
 *    Copyright 2015 West Coast Informatics, LLC
 */
package com.wci.umls.server.jpa.algo.insert;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.UUID;

import javax.persistence.Query;

import com.wci.umls.server.AlgorithmParameter;
import com.wci.umls.server.ValidationResult;
import com.wci.umls.server.helpers.ConfigUtility;
import com.wci.umls.server.helpers.FieldedStringTokenizer;
import com.wci.umls.server.helpers.KeyValuePair;
import com.wci.umls.server.helpers.PfsParameter;
import com.wci.umls.server.helpers.PrecedenceList;
import com.wci.umls.server.jpa.AlgorithmParameterJpa;
import com.wci.umls.server.jpa.ValidationResultJpa;
import com.wci.umls.server.jpa.algo.AbstractInsertMaintReleaseAlgorithm;
import com.wci.umls.server.jpa.algo.action.AddDemotionMolecularAction;
import com.wci.umls.server.jpa.algo.action.MoveMolecularAction;
import com.wci.umls.server.jpa.algo.action.SplitMolecularAction;
import com.wci.umls.server.jpa.algo.action.UndoMolecularAction;
import com.wci.umls.server.jpa.helpers.PfsParameterJpa;
import com.wci.umls.server.model.actions.MolecularAction;
import com.wci.umls.server.model.actions.MolecularActionList;
import com.wci.umls.server.model.content.Atom;
import com.wci.umls.server.model.content.Concept;
import com.wci.umls.server.services.handlers.ComputePreferredNameHandler;

/**
 * Implementation of an algorithm to import attributes.
 */
public class PrecomputedMoveAlgorithm
    extends AbstractInsertMaintReleaseAlgorithm {

  /** The merge set. */
  private String mergeSet;

  /** The merge level. */
  private String mergeLevel = null;

  /** The check names. */
  private List<String> checkNames;

  /** The change status. */
  private Boolean changeStatus = null;

  /** The make demotions. */
  private Boolean makeDemotions = null;

  /**
   * Instantiates an empty {@link PrecomputedMoveAlgorithm}.
   * @throws Exception if anything goes wrong
   */
  public PrecomputedMoveAlgorithm() throws Exception {
    super();
    setActivityId(UUID.randomUUID().toString());
    setWorkId("PRECOMPUTEDMERGE");
    setLastModifiedBy("admin");
  }

  /**
   * Check preconditions.
   *
   * @return the validation result
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public ValidationResult checkPreconditions() throws Exception {

    ValidationResult validationResult = new ValidationResultJpa();

    if (getProject() == null) {
      throw new Exception("Precomputed Merge requires a project to be set");
    }

    // Check the input directories

    final String srcFullPath =
        ConfigUtility.getConfigProperties().getProperty("source.data.dir")
            + File.separator + getProcess().getInputPath();

    setSrcDirFile(new File(srcFullPath));
    if (!getSrcDirFile().exists()) {
      throw new Exception("Specified input directory does not exist");
    }

    return validationResult;
  }

  /**
   * Compute.
   *
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  @SuppressWarnings("unchecked")
  public void compute() throws Exception {
    logInfo("Starting " + getName());
    logInfo("  integrity checks = " + checkNames);

    // Molecular actions WILL be generated by this algorithm
    setMolecularActionFlag(true);

    String previousVersion = getPreviousVersion(getProcess().getTerminology());
    if (previousVersion == null) {
      throw new Exception(
          "WARNING - previous version not found for terminology = "
              + getProcess().getTerminology());
    }
    String previousTerminologyVersion =
        getProcess().getTerminology() + previousVersion;
    String currentTerminologyVersion =
        getProcess().getTerminology() + getProcess().getVersion();

    Set<Long> atomIds = new HashSet<>();
    Set<Atom> atomsInMergeSet = new HashSet<>();
    Set<Long> atomIdsInMergeSet = new HashSet<>();
    Map<String, Atom> cuiPrefAtomMap = new HashMap<>();
    Map<Atom, Long> atomConceptIdMap = new HashMap<>();
    Map<Atom, String> atomCuiMap = new HashMap<>();
    Map<String, Set<Atom>> cuiAtomsMap = new HashMap<>();

    Set<String> ambigCuis = new HashSet<>();
    Map<String, Set<Long>> cuiConceptIdsMap = new HashMap<>();

    // Set up the search handler
    final ComputePreferredNameHandler prefNameHandler =
        getComputePreferredNameHandler(getProject().getTerminology());

    final PrecedenceList precedenceList = getPrecedenceList(
        getProject().getTerminology(), getProject().getVersion());

    // Set up a stats map to be passed into the merge function later
    final Map<String, Integer> statsMap = new HashMap<>();
    statsMap.put("metaMoveLines", 0);
    statsMap.put("skips", 0);
    statsMap.put("onlyAtomSkips", 0);
    statsMap.put("successfulDemotions", 0);
    statsMap.put("unsuccessfulDemotions", 0);
    statsMap.put("successfulSplits", 0);
    statsMap.put("unsuccessfulSplits", 0);
    statsMap.put("successfulMoves", 0);
    statsMap.put("unsuccessfulMoves", 0);

    try {

      logInfo("  Processing mergefacts.src");
      commitClearBegin();

      //
      // Load the mergefacts.src file
      //
      final List<String> lines = loadFileIntoStringList(getSrcDirFile(),
          "mergefacts.src", "(.*)" + "META-MOVED" + "(.*)", null, null);

      statsMap.put("metaMoveLines", lines.size());

      // Set the number of steps to twice the number of lines to be processed
      // This is so processing the mergefacts.src will show up as 50% of the
      // progress.
      setSteps(lines.size() * 2);

      logInfo("Looking up atoms for each META-MOVED line in mergefacts.src");
      commitClearBegin();

      final String fields[] = new String[12];

      for (final String line : lines) {

        // Check for a cancelled call once every 100 lines
        if (getStepsCompleted() % 100 == 0) {
          checkCancel();
        }

        FieldedStringTokenizer.split(line, "|", 12, fields);

        // Fields:
        // 0 id_1
        // 1 merge_level
        // 2 id_2
        // 3 source
        // 4 integrity_vector
        // 5 make_demotion
        // 6 change_status
        // 7 merge_set
        // 8 id_type_1
        // 9 id_qualifier_1
        // 10 id_type_2
        // 11 id_qualifier_2

        // e.g.
        // 275292735|SY|C0007581|MTH_2018AA||N|N|META-MOVED|SRC_ATOM_ID||CUI_CURRENT||

        // Use the first line encountered to set changeStatus, makeDemotions,
        // and merge_level
        // (they will be the same for the entire merge set)
        if (changeStatus == null) {
          changeStatus = fields[6].toUpperCase().equals("Y");
        }
        if (makeDemotions == null) {
          makeDemotions = fields[5].toUpperCase().equals("Y");
        }
        if (mergeLevel == null) {
          mergeLevel = fields[1];
        }

        final String cui = fields[2];
        final String srcAtomId = fields[0];

        // Load the atoms specified by SRC_ATOM_ID specified in mergefacts
        final Atom atom = (Atom) getComponent(fields[8], srcAtomId, "", null);

        if (atom == null) {
          logWarnAndUpdate(line,
              "WARNING - could not find Atom for SRC_ATOM_ID: " + srcAtomId);
          continue;
        }

        // This atom may be included in the META-MOVED list due to a known bug,
        // and may not actually need to be moved.
        // How to check: if the atom's previous release CUI
        // matches this release CUI, skip it.
        final String previousCUI =
            atom.getConceptTerminologyIds().get(previousTerminologyVersion);
        if (previousCUI == null) {
          throw new Exception(
              "Missing previous " + getProcess().getTerminology()
                  + " CUI for atom with source concept id=" + srcAtomId);
        }
        final String currentCUI =
            atom.getConceptTerminologyIds().get(currentTerminologyVersion);
        if (currentCUI == null) {
          throw new Exception("Missing current " + getProcess().getTerminology()
              + " CUI for atom with source concept id=" + srcAtomId);
        }

        if (previousCUI.equals(currentCUI)) {
          // remove 2 from the total step size, since this row won't be
          // processed in either loop
          statsMap.put("skips", statsMap.get("skips") + 1);
          setSteps(getSteps() - 2);
          continue;
        }

        // Populate the maps and sets
        atomsInMergeSet.add(atom);
        atomCuiMap.put(atom, cui);
        atomIds.add(atom.getId());
        if (!cuiAtomsMap.containsKey(cui)) {
          cuiAtomsMap.put(cui, new HashSet<>());
        }

        // Update the progress
        updateProgress();
      }

      // Find all atoms where an included CUI is its concept Terminology Id for
      // this MTH insertion
      logInfo("Looking up atoms associated with CUIs");

      Query query = getEntityManager().createQuery(
          "select a.id, value(b) from AtomJpa a join a.conceptTerminologyIds b "
              + "where ( KEY(b)  = :currentRelease and b in (:cuis))");
      query.setParameter("currentRelease",
          getProcess().getTerminology() + getProcess().getVersion());
      query.setParameter("cuis", cuiAtomsMap.keySet());

	  List<Object[]> results = query.getResultList();
      for (final Object[] result : results) {
        final Long id = Long.valueOf(result[0].toString());
        final String cui = result[1].toString();
        Atom atom2 = getAtom(id);
        // Don't include if this is a brand new atom (doesn't have a
        // previousRelease concept Terminology Id)
        // The reasoning is this should only track atoms that may have been
        // moved by NCIMTH editors in a different way than UMLS editors, and
        // brand new atoms can't have had that happen.
        if (atom2.getConceptTerminologyIds()
            .get(previousTerminologyVersion) == null) {
          continue;
        }
        cuiAtomsMap.get(cui).add(getAtom(id));
        atomIds.add(id);
      }

      // Use atomsInMergeSet to populate atomIdsInMergSet
      for (Atom atom : atomsInMergeSet) {
        atomIdsInMergeSet.add(atom.getId());
      }

      // Lookup the atoms' project concepts, to populate atomConceptIdMap
      logInfo("Looking up atoms' project concepts");
      query = getEntityManager()
          .createQuery("select a.id, c.id from ConceptJpa c join c.atoms a "
              + "where c.terminology = :terminology and a.id in (:atomIds)");
      query.setParameter("atomIds", atomIds);
      query.setParameter("terminology", getProject().getTerminology());

      results = query.getResultList();
      for (final Object[] result : results) {
        final Long atomId = Long.valueOf(result[0].toString());
        final Long conceptId = Long.valueOf(result[1].toString());
        atomConceptIdMap.put(getAtom(atomId), conceptId);
      }

      // Use cuiAtomsMap and atomConceptIdMap to create cuiConceptIdsMap
      logInfo("Creating cuiConceptIdsMap");
      for (Map.Entry<String, Set<Atom>> entry : cuiAtomsMap.entrySet()) {
        final String cui = entry.getKey();
        final Set<Atom> atoms = entry.getValue();

        if (!cuiConceptIdsMap.containsKey(cui)) {
          cuiConceptIdsMap.put(cui, new HashSet<>());
        }

        for (final Atom atom : atoms) {
          // Don't include atoms if they are in the mergeSet
          if (atomIdsInMergeSet.contains(atom.getId())) {
            continue;
          }
          final Long conceptId = atomConceptIdMap.get(atom);
          cuiConceptIdsMap.get(cui).add(conceptId);
        }
      }

      // Look through cuiConceptIdsMap to identify ambigCuis (CUIs that map to
      // more than one concept Id)
      logInfo("Identifying ambigCuis");
      for (Map.Entry<String, Set<Long>> entry : cuiConceptIdsMap.entrySet()) {
        final String cui = entry.getKey();
        final Set<Long> conceptIds = entry.getValue();

        if (conceptIds.size() > 1) {
          ambigCuis.add(cui);
        }
      }

      // Sort the atoms in the merge set
      logInfo("Sorting atoms in merge set");
      List<Atom> prefSortedAtoms = prefNameHandler
          .sortAtoms(new ArrayList<>(atomsInMergeSet), precedenceList);

      // Find the highest ranking atom for each cui
      logInfo("Finding preferred atom for each cui");
      for (Map.Entry<String, Set<Atom>> entry : cuiAtomsMap.entrySet()) {
        final String cui = entry.getKey();
        final Set<Atom> atoms = entry.getValue();

        final Atom preferredAtom =
            prefNameHandler.sortAtoms(atoms, precedenceList).get(0);
        cuiPrefAtomMap.put(cui, preferredAtom);
      }

      // We've built up all of the requisite maps - now we can actually perform
      // the actions
      logInfo("Performing atom movements");
      for (final Atom atom : prefSortedAtoms) {
        String cui = atomCuiMap.get(atom);
        long conceptId = atomConceptIdMap.get(atom);

        // skip if this is the only atom in its concept
        if (getConcept(conceptId).getAtoms().size() == 1) {
          statsMap.put("onlyAtomSkips", statsMap.get("onlyAtomSkips") + 1);
          updateProgress();
          continue;
        }

        // If this is an ambiguous cui, make demotions to all concepts
        if (ambigCuis.contains(cui)) {
          for (final long conceptId2 : cuiConceptIdsMap.get(cui)) {
            if (conceptId != conceptId2) {
              // make demotion from atom -> prefAtom of conceptId2 (with cui as
              // UMLS latest CUI)
              Concept concept2 = getConcept(conceptId2);
              Set<Atom> cuiAtoms = new HashSet<>();
              for (Atom atom2 : concept2.getAtoms()) {
                String umlsCurrentCui = atom2.getConceptTerminologyIds()
                    .get(currentTerminologyVersion);
                if (umlsCurrentCui != null && umlsCurrentCui.equals(cui)) {
                  cuiAtoms.add(atom2);
                }
              }
              final Atom preferredConcept2Atom =
                  prefNameHandler.sortAtoms(cuiAtoms, precedenceList).get(0);

              final AddDemotionMolecularAction action =
                  new AddDemotionMolecularAction();
              action.setTransactionPerOperation(false);
              action.setProject(getProject());
              action.setTerminology(getProject().getTerminology());
              action.setVersion(getProject().getVersion());
              action.setWorkId(getWorkId());
              action.setActivityId(getActivityId());
              action.setAtomId(atom.getId());
              action.setAtomId2(preferredConcept2Atom.getId());
              action.setChangeStatusFlag(true);
              action.setConceptId(conceptId);
              action.setConceptId2(conceptId2);
              action.setLastModifiedBy(getLastModifiedBy());
              ValidationResult demotionValidationResult =
                  action.performMolecularAction(action, getLastModifiedBy(),
                      false, false);

              // If there is already a demotion between these two atoms, it will
              // return a validation error
              if (!demotionValidationResult.isValid()) {
                statsMap.put("unsuccessfulDemotions",
                    statsMap.get("unsuccessfulDemotions") + 1);

                addLogEntry(getLastModifiedBy(), getProject().getId(),
                    conceptId, getActivityId(), getWorkId(),
                    "FAIL " + action.getName() + " to concept " + conceptId2
                        + ": " + demotionValidationResult);
                addLogEntry(getLastModifiedBy(), getProject().getId(),
                    conceptId2, getActivityId(), getWorkId(),
                    "FAIL " + action.getName() + " from concept " + conceptId
                        + ": " + demotionValidationResult);
              }
              // Otherwise, the demotion was successfully added
              else {
                statsMap.put("successfulDemotions",
                    statsMap.get("successfulDemotions") + 1);
              }
              action.close();

            }
          }
          updateProgress();
          continue;
        }

        Atom prefAtom = cuiPrefAtomMap.get(cui);

        if (atom.getId().equals(prefAtom.getId())) {
          // split atom from conceptId
          // copy STY but don't copy relationships

          // Create and set up a split action
          final SplitMolecularAction action = new SplitMolecularAction();
          // Configure the action
          action.setProject(getProject());
          action.setActivityId(getActivityId());
          action.setWorkId(getActivityId());
          action.setConceptId(conceptId);
          action.setConceptId2(null);
          action.setLastModifiedBy(getLastModifiedBy());
          action.setTransactionPerOperation(false);
          action.setMolecularActionFlag(true);
          action.setChangeStatusFlag(true);

          action.setAtomIds(new ArrayList<>(Arrays.asList(atom.getId())));
          action.setRelationshipType(mergeLevel);
          action.setCopyRelationships(false);
          action.setCopySemanticTypes(true);

          // Perform the action
          final ValidationResult validationResult =
              action.performMolecularAction(action, getLastModifiedBy(), false,
                  false);

          // If the action failed, log the failure
          if (!validationResult.isValid()) {
            statsMap.put("unsuccessfulSplits",
                statsMap.get("unsuccessfulSplits") + 1);

            addLogEntry(getLastModifiedBy(), getProject().getId(), conceptId,
                getActivityId(), getWorkId(),
                "FAIL " + action.getName() + " atom " + atom.getId()
                    + " from concept " + conceptId + ": " + validationResult);
          } else {
            statsMap.put("successfulSplits",
                statsMap.get("successfulSplits") + 1);
          }
          action.close();

          // commit at this point, so we can finalize the atom's new concept
          commitClearBegin();

          // update atomConceptIdMap for the split atom
          query = getEntityManager()
              .createQuery("select c.id from ConceptJpa c join c.atoms a "
                  + "where c.terminology = :terminology and a.id = :atomId");
          query.setParameter("atomId", atom.getId());
          query.setParameter("terminology", getProject().getTerminology());

		  List<Long> longResults = query.getResultList();
          for (final Long id : longResults) {
            atomConceptIdMap.put(atom, id);
          }

          updateProgress();
          continue;
        }

        else if (conceptId == atomConceptIdMap.get(prefAtom)) {
          // n/a

          updateProgress();
          continue;
        }

        else {
          // move atom to concept id of the prefAtom
          final Long destinationConceptId = atomConceptIdMap.get(prefAtom);

          // Create and set up a move action
          final MoveMolecularAction action = new MoveMolecularAction();
          // Configure the action
          action.setProject(getProject());
          action.setActivityId(getActivityId());
          action.setWorkId(getActivityId());
          action.setConceptId(conceptId);
          action.setConceptId2(destinationConceptId);
          action.setLastModifiedBy(getLastModifiedBy());
          action.setTransactionPerOperation(false);
          action.setMolecularActionFlag(true);
          action.setChangeStatusFlag(true);

          action.setAtomIds(new ArrayList<>(Arrays.asList(atom.getId())));

          // Perform the action
          final ValidationResult validationResult =
              action.performMolecularAction(action, getLastModifiedBy(), false,
                  false);

          // If the action failed, log the failure
          if (!validationResult.isValid()) {
            statsMap.put("unsuccessfulMoves",
                statsMap.get("unsuccessfulMoves") + 1);

            addLogEntry(getLastModifiedBy(), getProject().getId(), conceptId,
                getActivityId(), getWorkId(),
                "FAIL " + action.getName() + " to concept "
                    + destinationConceptId + ": " + validationResult);
            addLogEntry(getLastModifiedBy(), getProject().getId(),
                destinationConceptId, getActivityId(), getWorkId(),
                "FAIL " + action.getName() + " from concept " + conceptId + ": "
                    + validationResult);
          } else {
            statsMap.put("successfulMoves",
                statsMap.get("successfulMoves") + 1);
          }
          action.close();

          // update atomConceptIdMap for the moved atom
          atomConceptIdMap.put(atom, destinationConceptId);
          updateProgress();

        }

      }

      commitClearBegin();

      logInfo("  META-MOVE lines from mergefacts.src = "
          + statsMap.get("metaMoveLines"));
      logInfo("  META_MOVE lines skipped because move was not required = "
          + statsMap.get("skips"));
      logInfo("  META_MOVE lines skipped because only one atom in concept = "
          + statsMap.get("onlyAtomSkips"));
      logInfo("  successful moves count = " + statsMap.get("successfulMoves"));
      logInfo(
          "  unsuccessful moves count = " + statsMap.get("unsuccessfulMoves"));
      logInfo(
          "  successful splits count = " + statsMap.get("successfulSplits"));
      logInfo("  unsuccessful splits count = "
          + statsMap.get("unsuccessfulSplits"));
      logInfo("  successful demotions count = "
          + statsMap.get("successfulDemotions"));
      logInfo("  unsuccessful demotions count = "
          + statsMap.get("unsuccessfulDemotions"));

      logInfo("Finished " + getName());

    } catch (Exception e) {
      logError("Unexpected problem - " + e.getMessage());
      throw e;
    } finally {
      // Clear the caches to free up memory
      clearCaches();
    }

  }

  /**
   * Reset.
   *
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public void reset() throws Exception {
    logInfo("Starting RESET " + getName());

    // Collect any merges previously performed, and UNDO them in reverse order
    final PfsParameter pfs = new PfsParameterJpa();
    pfs.setAscending(false);
    pfs.setSortField("lastModified");
    final MolecularActionList molecularActions =
        findMolecularActions(null, getProject().getTerminology(),
            getProject().getVersion(), "activityId:" + getActivityId(), pfs);

    for (final MolecularAction molecularAction : molecularActions
        .getObjects()) {
      // Create and set up an undo action
      final UndoMolecularAction undoAction = new UndoMolecularAction();

      // Configure and run the undo action
      undoAction.setProject(getProject());
      undoAction.setActivityId(molecularAction.getActivityId());
      undoAction.setConceptId(null);
      undoAction.setConceptId2(molecularAction.getComponentId2());
      undoAction.setLastModifiedBy(molecularAction.getLastModifiedBy());
      undoAction.setTransactionPerOperation(false);
      undoAction.setMolecularActionFlag(false);
      undoAction.setChangeStatusFlag(true);
      undoAction.setMolecularActionId(molecularAction.getId());
      undoAction.setForce(false);
      undoAction.performMolecularAction(undoAction, getLastModifiedBy(), false,
          false);

      undoAction.close();
    }
    logInfo("Finished RESET " + getName());
  }

  /* see superclass */
  @Override
  public void checkProperties(Properties p) throws Exception {
    checkRequiredProperties(new String[] {
        "mergeSet"
    }, p);
  }

  /* see superclass */
  @Override
  public void setProperties(Properties p) throws Exception {

    if (p.getProperty("mergeSet") != null) {
      mergeSet = String.valueOf(p.getProperty("mergeSet"));
    }
    if (p.getProperty("checkNames") != null) {
      checkNames =
          Arrays.asList(String.valueOf(p.getProperty("checkNames")).split(";"));
    }

  }

  /**
   * Returns the parameters.
   *
   * @return the parameters
   */
  /* see superclass */
  @Override
  public List<AlgorithmParameter> getParameters() throws Exception {
    final List<AlgorithmParameter> params = super.getParameters();

    // Run checkPreconditions to set the SrcDirFile, since it will be used by
    // the merge
    // set parameter
    try {
      checkPreconditions();
    } catch (Exception e) {
      // Do nothing
    }

    AlgorithmParameter param = new AlgorithmParameterJpa("Merge Set",
        "mergeSet", "The merge set to perform the merges on", "e.g. NCI-SY", 10,
        AlgorithmParameter.Type.ENUM, "");
    // Look for the mergefacts.src file and populate the enum based on the
    // merge_set column.
    List<String> mergeSets = getMergeSets(getSrcDirFile());

    // If the file isn't found, or the file contains no mergeSets, set the
    // parameter to a free-entry string
    if (mergeSets == null || mergeSets.size() == 0) {
      param.setType(AlgorithmParameter.Type.STRING);
    } else {
      param.setPossibleValues(mergeSets);
    }
    params.add(param);

    param = new AlgorithmParameterJpa("Integrity Checks", "checkNames",
        "The names of the integrity checks to run", "e.g. MGV_B", 10,
        AlgorithmParameter.Type.MULTI, "");

    List<String> validationChecks = new ArrayList<>();
    for (final KeyValuePair validationCheck : getValidationCheckNames()
        .getKeyValuePairs()) {
      // Add handler Name to ENUM list
      validationChecks.add(validationCheck.getKey());
    }

    Collections.sort(validationChecks);
    param.setPossibleValues(validationChecks);
    params.add(param);

    return params;
  }

  /* see superclass */
  @Override
  public String getDescription() {
    return "Loads and performs moves based on mergefacts.src.";
  }
}