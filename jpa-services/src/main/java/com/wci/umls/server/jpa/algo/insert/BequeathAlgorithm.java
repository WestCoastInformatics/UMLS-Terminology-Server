/*
 *    Copyright 2015 West Coast Informatics, LLC
 */
package com.wci.umls.server.jpa.algo.insert;

import java.io.File;
import java.util.HashSet;
import java.util.List;
import java.util.Properties;
import java.util.Set;
import java.util.UUID;

import com.wci.umls.server.AlgorithmParameter;
import com.wci.umls.server.ValidationResult;
import com.wci.umls.server.helpers.ConfigUtility;
import com.wci.umls.server.helpers.QueryType;
import com.wci.umls.server.jpa.ValidationResultJpa;
import com.wci.umls.server.jpa.algo.AbstractInsertMaintReleaseAlgorithm;
import com.wci.umls.server.jpa.content.ConceptJpa;
import com.wci.umls.server.jpa.content.ConceptRelationshipJpa;
import com.wci.umls.server.model.content.Concept;
import com.wci.umls.server.model.content.ConceptRelationship;
import com.wci.umls.server.model.meta.Terminology;
import com.wci.umls.server.model.workflow.WorkflowStatus;

/**
 * Implementation of an algorithm to bequeath old versioned SRC concepts.
 */
public class BequeathAlgorithm extends AbstractInsertMaintReleaseAlgorithm {

  /**
   * Instantiates an empty {@link BequeathAlgorithm}.
   * @throws Exception if anything goes wrong
   */
  public BequeathAlgorithm() throws Exception {
    super();
    setActivityId(UUID.randomUUID().toString());
    setWorkId("BEQUEATH");
    setLastModifiedBy("admin");
  }

  /* see superclass */
  @Override
  public ValidationResult checkPreconditions() throws Exception {

    ValidationResult validationResult = new ValidationResultJpa();

    if (getProject() == null) {
      throw new Exception("Bequeath requires a project to be set");
    }

    // Check the input directories

    final String srcFullPath =
        ConfigUtility.getConfigProperties().getProperty("source.data.dir")
            + File.separator + getProcess().getInputPath();

    setSrcDirFile(new File(srcFullPath));
    if (!getSrcDirFile().exists()) {
      throw new Exception("Specified input directory does not exist");
    }

    return validationResult;
  }

  /* see superclass */
  @Override
  public void compute() throws Exception {
    logInfo("Starting " + getName());

    // No molecular actions will be generated by this algorithm
    setMolecularActionFlag(false);

    try {

      logInfo("  Bequeathing old versioned SRC concepts");
      commitClearBegin();

      // Get all terminologies referenced in the sources.src file
      Set<Terminology> terminologies = new HashSet<>();
      terminologies = getReferencedTerminologies();

      setSteps(terminologies.size());

      for (final Terminology terminology : terminologies) {
        checkCancel();

        final String fromConceptQuery =
            "atoms.terminology:SRC AND atoms.termType:VAB AND atoms.codeId:V-"
                + terminology.getTerminology() + "* AND NOT atoms.codeId:V-"
                + terminology.getTerminology() + "_" + terminology.getVersion();

        // Execute query to get from concept Ids
        final List<Long> fromConceptIds =
            executeSingleComponentIdQuery(fromConceptQuery, QueryType.LUCENE,
                getDefaultQueryParams(getProject()), ConceptJpa.class, false);

        final String toConceptQuery =
            "atoms.terminology:SRC AND atoms.termType:RAB AND atoms.codeId:V-"
                + terminology.getTerminology();

        // Execute query to get to concept Ids
        final List<Long> toConceptIds =
            executeSingleComponentIdQuery(toConceptQuery, QueryType.LUCENE,
                getDefaultQueryParams(getProject()), ConceptJpa.class, false);

        // Load the to Concept (there can only be one)
        if (toConceptIds.size() != 1) {
          logWarn("Unexpected number of concepts returned by: " + toConceptQuery
              + " Could not process bequeathals for referenced terminology: "
              + terminology);
          updateProgress();
          continue;
        }
        final Concept toConcept = getConcept(toConceptIds.get(0));

        // Load all from concepts, and create "BRO" relationships from each one
        // to the to concept
        for (Long fromConceptId : fromConceptIds) {
          final Concept fromConcept = getConcept(fromConceptId);

          // If "BRO" relationship already exists between these concepts, don't
          // add a new one.
          boolean existingRelFound = false;
          for (ConceptRelationship existingRel : fromConcept
              .getRelationships()) {
            if (existingRel.getTo().getId().equals(toConcept.getId())
                && existingRel.getRelationshipType().equals("BRO")) {
              existingRelFound = true;
              break;
            }
          }
          if (existingRelFound) {
            continue;
          }

          ConceptRelationship bequeathRel = new ConceptRelationshipJpa();
          bequeathRel.setRelationshipType("BRO");
          bequeathRel.setAdditionalRelationshipType("");
          bequeathRel.setTerminologyId("");
          bequeathRel.setTerminology(getProject().getTerminology());
          bequeathRel.setVersion(getProject().getVersion());
          bequeathRel.setFrom(fromConcept);
          bequeathRel.setTo(toConcept);
          bequeathRel.setWorkflowStatus(WorkflowStatus.READY_FOR_PUBLICATION);
          bequeathRel = (ConceptRelationship) addRelationship(bequeathRel);

          ConceptRelationship inverseBequeathRel =
              createInverseConceptRelationship(bequeathRel);
          inverseBequeathRel =
              (ConceptRelationship) addRelationship(inverseBequeathRel);

          fromConcept.getRelationships().add(bequeathRel);
          toConcept.getRelationships().add(inverseBequeathRel);

          updateConcept(fromConcept);
          updateConcept(toConcept);
        }

        // Update the progress
        updateProgress();
      }

      commitClearBegin();

      logInfo("Finished " + getName());

    } catch (

    Exception e) {
      logError("Unexpected problem - " + e.getMessage());
      throw e;
    }

  }

  /* see superclass */
  @Override
  public void reset() throws Exception {
    logInfo("Starting RESET " + getName());
    // n/a - No reset
    logInfo("Finished RESET " + getName());
  }

  /* see superclass */
  @Override
  public void checkProperties(Properties p) throws Exception {
    // n/a
  }

  /* see superclass */
  @Override
  public void setProperties(Properties p) throws Exception {
    // n/a
  }

  /* see superclass */
  @Override
  public List<AlgorithmParameter> getParameters() throws Exception {
    final List<AlgorithmParameter> params = super.getParameters();

    return params;
  }

  @Override
  public String getDescription() {
    return "Bequeaths old-versioned SRC concept(s) to the root SRC concept";
  }

}