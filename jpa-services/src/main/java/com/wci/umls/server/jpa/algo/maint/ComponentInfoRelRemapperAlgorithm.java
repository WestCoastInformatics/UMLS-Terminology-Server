/*
 *    Copyright 2015 West Coast Informatics, LLC
 */
package com.wci.umls.server.jpa.algo.maint;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.UUID;

import com.wci.umls.server.AlgorithmParameter;
import com.wci.umls.server.ValidationResult;
import com.wci.umls.server.helpers.ComponentInfo;
import com.wci.umls.server.helpers.QueryType;
import com.wci.umls.server.jpa.ValidationResultJpa;
import com.wci.umls.server.jpa.algo.AbstractInsertMaintReleaseAlgorithm;
import com.wci.umls.server.jpa.content.ComponentInfoRelationshipJpa;
import com.wci.umls.server.model.content.Component;
import com.wci.umls.server.model.content.ComponentInfoRelationship;
import com.wci.umls.server.model.meta.IdType;
import com.wci.umls.server.model.meta.Terminology;

/**
 * Algorithm responsible for re-mapping component info relationships.
 */
public class ComponentInfoRelRemapperAlgorithm
    extends AbstractInsertMaintReleaseAlgorithm {

  /** The update count. */
  private int updateCount = 0;

  /**
   * Instantiates an empty {@link ComponentInfoRelRemapperAlgorithm}.
   *
   * @throws Exception the exception
   */
  public ComponentInfoRelRemapperAlgorithm() throws Exception {
    super();
    setActivityId(UUID.randomUUID().toString());
    setWorkId("COMPONENTINFORELREMAPPER");
    setLastModifiedBy("admin");
  }

  /* see superclass */
  @Override
  public ValidationResult checkPreconditions() throws Exception {

    ValidationResult validationResult = new ValidationResultJpa();

    if (getProject() == null) {
      throw new Exception(getName() + " requires a project to be set");
    }

    return validationResult;
  }

  /* see superclass */
  @Override
  public void compute() throws Exception {
    logInfo("Starting " + getName());

    // No molecular actions will be generated by this algorithm
    setMolecularActionFlag(false);

    // Cache the current terminologies
    final Map<String, String> currentTerminologyVersions = new HashMap<>();
    for (final Terminology terminology : getCurrentTerminologies()
        .getObjects()) {
      currentTerminologyVersions.put(terminology.getTerminology(),
          terminology.getVersion());
    }

    // Find all publishable component info relationships
    final String query = "SELECT r.id FROM ComponentInfoRelationshipJpa r "
        + "WHERE r.publishable=true";

    final List<Long> componentInfoRelIds = executeSingleComponentIdQuery(query,
        QueryType.JPQL, getDefaultQueryParams(getProject()),
        ComponentInfoRelationshipJpa.class, false);

    setSteps(componentInfoRelIds.size());

    for (final Long id : componentInfoRelIds) {
      final ComponentInfoRelationship componentInfoRelationship =
          (ComponentInfoRelationship) getRelationship(id,
              ComponentInfoRelationshipJpa.class);
      boolean relNeedsUpdating = false;

      // Get from component
      final ComponentInfo fromComponentInfo =
          componentInfoRelationship.getFrom();
      final Component fromComponent = getComponent(
          getType(componentInfoRelationship.getFrom().getType(),
              fromComponentInfo.getTerminologyId()),
          fromComponentInfo.getTerminologyId(),
          fromComponentInfo.getTerminology(), null);

      // If from component doesn't exist, mark the relationship as unpublishable
      // (and warn)
      if (fromComponent == null || !fromComponent.isPublishable()) {
        componentInfoRelationship.setPublishable(false);
        updateRelationship(componentInfoRelationship);
        logWarn(
            "WARNING - publishable from component cannot be found for component info relationship = "
                + componentInfoRelationship);
        updateProgress();
        continue;
      }

      // If from component exists and the terminology is not the current
      // version, make it the current version (and updateRelationship)
      if (!fromComponentInfo.getVersion().equals(
          currentTerminologyVersions.get(fromComponent.getTerminology()))) {
        fromComponentInfo.setVersion(
            currentTerminologyVersions.get(fromComponent.getTerminology()));

        componentInfoRelationship.setFrom(fromComponentInfo);
        relNeedsUpdating = true;
      }

      // Get to object
      final ComponentInfo toComponentInfo = componentInfoRelationship.getTo();
      final Component toComponent = getComponent(
          getType(toComponentInfo.getType(),
              toComponentInfo.getTerminologyId()),
          toComponentInfo.getTerminologyId(), toComponentInfo.getTerminology(),
          null);

      // If to component doesn't exist, mark the relationship as unpublishable
      // (and warn)
      if (toComponent == null || !toComponent.isPublishable()) {
        componentInfoRelationship.setPublishable(false);
        updateRelationship(componentInfoRelationship);
        logWarn(
            "WARNING - publishable to component cannot be found for component info relationship = "
                + componentInfoRelationship);
        updateProgress();
        continue;
      }

      // If to component exists and the terminology is not the current
      // version, make it the current version (and updateRelationship)
      if (!toComponentInfo.getVersion().equals(
          currentTerminologyVersions.get(toComponentInfo.getTerminology()))) {
        toComponentInfo.setVersion(
            currentTerminologyVersions.get(toComponentInfo.getTerminology()));

        componentInfoRelationship.setTo(toComponentInfo);
        relNeedsUpdating = true;
      }

      // Update the relationship, if needed
      if (relNeedsUpdating) {
        updateRelationship(componentInfoRelationship);
        updateCount++;
      }

      updateProgress();
    }

    // Always clean up after yourself...
    clearCaches();

    commitClearBegin();

    logInfo("  updated count = " + updateCount);
    logInfo("Finished " + getName());
  }

  /**
   * Returns the type.
   *
   * @param idType the id type
   * @return the type
   * @throws Exception the exception
   */
  
  private String getType(IdType idType, String terminologyId) throws Exception {
    final String stringType;
    switch (idType) {
      case ATOM:
        if (terminologyId.startsWith("A")) {
          stringType = "AUI";
        } else {
          stringType = "SRC_ATOM_ID";
        }
        break;
      case DESCRIPTOR:
        stringType = "SOURCE_DUI";
        break;
      case CODE:
        stringType = "CODE_SOURCE";
        break;
      case CONCEPT:
        stringType = "SOURCE_CUI";
        break;
      default:
        throw new Exception("ERROR - Type not handled = " + idType);
    }
    return stringType;
  }

  /* see superclass */
  @Override
  public void reset() throws Exception {
    logInfo("Starting RESET " + getName());
    // n/a - No reset
    logInfo("Finished RESET " + getName());
  }

  /* see superclass */
  @Override
  public void checkProperties(Properties p) throws Exception {
    // n/a
  }

  /* see superclass */
  @Override
  public void setProperties(Properties p) throws Exception {
    // n/a
  }

  /* see superclass */
  @Override
  public List<AlgorithmParameter> getParameters() throws Exception {
    final List<AlgorithmParameter> params = super.getParameters();
    return params;
  }

  /* see superclass */
  @Override
  public String getDescription() {
    return "Remaps component info relationships";
  }
}