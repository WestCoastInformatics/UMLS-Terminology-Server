/*
 *    Copyright 2015 West Coast Informatics, LLC
 */
package com.wci.umls.server.jpa.algo.insert;

import static org.junit.Assert.fail;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.UUID;

import javax.persistence.Query;

import com.wci.umls.server.AlgorithmParameter;
import com.wci.umls.server.ValidationResult;
import com.wci.umls.server.helpers.Branch;
import com.wci.umls.server.helpers.ConfigUtility;
import com.wci.umls.server.helpers.SearchResultList;
import com.wci.umls.server.jpa.ValidationResultJpa;
import com.wci.umls.server.jpa.algo.AbstractInsertMaintReleaseAlgorithm;
import com.wci.umls.server.jpa.algo.action.AbstractMolecularAction;
import com.wci.umls.server.jpa.algo.action.AddRelationshipMolecularAction;
import com.wci.umls.server.jpa.algo.action.ApproveMolecularAction;
import com.wci.umls.server.jpa.content.ConceptRelationshipJpa;
import com.wci.umls.server.model.content.Atom;
import com.wci.umls.server.model.content.AtomRelationship;
import com.wci.umls.server.model.content.Concept;
import com.wci.umls.server.model.content.ConceptRelationship;
import com.wci.umls.server.model.workflow.WorkflowStatus;

/**
 * In effort to reduce deleted_cuis, create bequeathals based on RO/RB concept rels
 * when there are no PAR rels.
 */
public class CreateConceptRelBequeathalAlgorithm extends AbstractInsertMaintReleaseAlgorithm {

  /**
   * Instantiates an empty {@link CreateConceptRelBequeathalAlgorithm}.
   * @throws Exception if anything goes wrong
   */
  public CreateConceptRelBequeathalAlgorithm() throws Exception {
    super();
    setActivityId(UUID.randomUUID().toString());
    setWorkId("CREATECONCEPTRELBEQUEATH");
    setLastModifiedBy("admin");
  }

  /* see superclass */
  @Override
  public ValidationResult checkPreconditions() throws Exception {

    ValidationResult validationResult = new ValidationResultJpa();

    if (getProject() == null) {
      throw new Exception("Create concept rel bequeath requires a project to be set");
    }

    // Check the input directories

    final String srcFullPath =
        ConfigUtility.getConfigProperties().getProperty("source.data.dir")
            + File.separator + getProcess().getInputPath();

    setSrcDirFile(new File(srcFullPath));
    if (!getSrcDirFile().exists()) {
      throw new Exception("Specified input directory does not exist");
    }

    return validationResult;
  }

  /* see superclass */
  @Override
  public void compute() throws Exception {
    logInfo("Starting " + getName());

    // No molecular actions will be generated by this algorithm
    setMolecularActionFlag(false);

    AddRelationshipMolecularAction action = new AddRelationshipMolecularAction();
    AbstractMolecularAction approveAction = new ApproveMolecularAction();
    
    try {

      Set<Concept> deletedCuis = new HashSet<>();
      Query query = getEntityManager().createNativeQuery(
          "SELECT   DISTINCT c.id conceptId FROM   concepts c,   "
          + "concepts_atoms ca,   atoms a WHERE   c.terminology = 'NCIMTH'   "
          + "AND c.id != c.terminologyId   AND c.id = ca.concepts_id   AND "
          + "ca.atoms_id = a.id   "
          + "AND a.publishable = FALSE   AND NOT c.id IN ("
          +   "SELECT       DISTINCT c.id conceptId     " 
          +   " FROM       concepts c,       concepts_atoms ca,       atoms a     "
          +   " WHERE       c.terminology = 'NCIMTH'       AND c.id = ca.concepts_id   "
          +   " AND ca.atoms_id = a.id       AND a.publishable = TRUE   )   " 
          +   " AND NOT c.id IN (     "
          +   "   SELECT       DISTINCT c.id conceptId     "
          +   "    FROM       concepts c,       concept_relationships cr     "
          +   "    WHERE       c.terminology = 'NCIMTH'       AND c.id = cr.from_id       "
          +   "    AND cr.relationshipType like 'B%'   )   AND NOT c.id IN (     "
          +   "      SELECT       c.id conceptId     " 
          +   "        FROM       concepts c,       concepts_atoms ca     "
          +   "        WHERE       c.terminology = 'NCIMTH'       "
          +   "        AND c.id = ca.concepts_id       AND ca.concepts_id IN (         "
          +   "      SELECT           ca.concepts_id         FROM           concepts_atoms ca,           atoms a         " 
          +   "        WHERE           ca.atoms_id = a.id           "
          +   "        AND a.terminology IN ('MTH', 'NCIMTH')           " 
          +   "        AND a.termType = 'PN'       )     GROUP BY       ca.concepts_id     "
          +   "        HAVING       COUNT(DISTINCT ca.atoms_id) = 1   )"
          +   " AND NOT c.id IN (   "
          +   "   SELECT  " 
          +   "     ca.concepts_id conceptId  "
          +   "   FROM  "
          +   "     mrcui mr,  "
          +  "      atomjpa_conceptterminologyids ac,  "
          +  "      concepts_atoms ca,  "
          +  "      concepts cpt  "
          + "     WHERE  "
          +  "      mr.cui1 = ac.conceptTerminologyIds  "
          +  "      AND ca.atoms_id = ac.AtomJpa_id  "
          +  "      AND cpt.id = ca.concepts_id  "
          +  "      AND cpt.terminology = 'NCIMTH'  "
          +  "      AND ac.conceptTerminologyIds_KEY = 'NCIMTH'  "
          +  "      AND mr.rel = 'DEL'  )"
        
          
          );
      

      List<Object> list = query.getResultList();
      setSteps(list.size());
      List<Long> conceptsToBeApproved = new ArrayList<>();
      
     /* List<Object> list = new ArrayList<>();
      list.add(401456L);
      list.add(155706L);
      list.add(401471L);
      setSteps(3);*/
      // get the deleted cui concepts that will be evaluated
      for (final Object entry : list) {
        final Long id = Long.valueOf(entry.toString());
        Concept c = getConcept(id);
        deletedCuis.add(c);
        c.getAtoms().size();
        c.getRelationships().size();
        c.getInverseRelationships().size();
      }
      
      // for each deleted cui concept, find potential bequeathal rels
      for (Concept c : deletedCuis) {
        Map<Concept, Concept> potentialROBequeathals = new HashMap<>();
        Map<Concept, Concept> potentialRBBequeathals = new HashMap<>();
        for (ConceptRelationship cr : c.getInverseRelationships()) {
          if (cr.getRelationshipType().equals("RB")) {
            Concept otherConcept = cr.getFrom();
            Concept ncimthOtherConcept = getConcept(otherConcept.getId());
            if (noXRRel(c, ncimthOtherConcept)
                && ncimthOtherConcept.isPublishable()) {
              potentialRBBequeathals.put(c, ncimthOtherConcept);
            }
          } else if (cr.getRelationshipType().equals("RO")) {
            Concept otherConcept = cr.getFrom();
            Concept ncimthOtherConcept = getConcept(otherConcept.getId());
            if (noXRRel(c, ncimthOtherConcept)
                && ncimthOtherConcept.isPublishable()) {
              potentialROBequeathals.put(c, ncimthOtherConcept);
            }
          }
        }

        // choose which one bequeathal to add
        ConceptRelationship relationship = new ConceptRelationshipJpa();

        if (potentialRBBequeathals.size() >= 1) {
          relationship.setFrom(potentialRBBequeathals.entrySet().stream()
              .findFirst().get().getKey());
          relationship.setTo(potentialRBBequeathals.entrySet().stream()
              .findFirst().get().getValue());
          relationship.setRelationshipType("BRN");
          logInfo("[AddConceptBequeathals RB] " + relationship.getFrom().getId() + " "
              + relationship.getFrom().getTerminologyId() + " RB " +
              relationship.getTo().getId() + " " + relationship.getTo().getTerminologyId());
        } else if (potentialROBequeathals.size() >= 1) {
          relationship.setFrom(potentialROBequeathals.entrySet().stream()
              .findFirst().get().getKey());
          relationship.setTo(potentialROBequeathals.entrySet().stream()
              .findFirst().get().getValue());
          relationship.setRelationshipType("BRO");
          logInfo("[AddConceptBequeathals RO] " + relationship.getFrom().getId() + " "
              + relationship.getFrom().getTerminologyId() + " RO " +
              relationship.getTo().getId() + " " + relationship.getTo().getTerminologyId());
        } else {
          continue;
        }

        // save prev workflow state, bc AddRelationshipMolecularAction will
        // change all states to NEEDS_REVIEW, but editors won't want to review
        // all of these, so we'll need to approve all of those that were
        // READY_FOR_PUBLICATION or PUBLISHED
        WorkflowStatus fromConceptPrevWorkflow =
            relationship.getFrom().getWorkflowStatus();
        WorkflowStatus toConceptPrevWorkflow =
            relationship.getTo().getWorkflowStatus();

        // Instantiate services
        action =
            new AddRelationshipMolecularAction();

        // All new content is unpublished and publishable
        relationship.setPublished(false);
        relationship.setPublishable(true);

        relationship.setTerminology("NCIMTH");
        relationship.setVersion("latest");
        relationship.setAdditionalRelationshipType("");
        relationship.setTerminologyId("");

        // Set defaults for a concept level relationship
        relationship.setStated(true);
        relationship.setInferred(true);
        relationship.setSuppressible(false);
        relationship.setObsolete(false);

        // If RelGroup is null, set to blank
        if (relationship.getGroup() == null) {
          relationship.setGroup("");
        }

        // Configure the action
        action.setProject(getProject());
        action.setActivityId("AddRORBConceptBequeathals");
        // The relationship is FROM conceptId -> conceptId2, and REL
        // is represented in that direction
        action.setConceptId(relationship.getFrom().getId());
        action.setConceptId2(relationship.getTo().getId());
        action.setLastModifiedBy("loader");
        action.setLastModified(
            relationship.getFrom().getLastModified().getTime());
        action.setOverrideWarnings(true);
        action.setTransactionPerOperation(false);
        action.setMolecularActionFlag(true);
        action.setChangeStatusFlag(true);

        action.setRelationship(relationship);

        // Perform the action
        final ValidationResult validationResult =
            action.performMolecularAction(action, "loader", true, false);

        // If the action failed, bail out now.
        if (!validationResult.isValid()) {
          logError("Unexpected problem - " + validationResult);
        }
        
        action.close();

        // add to list if concepts were already reviewed and require ApprovalMolecularAction
        if (fromConceptPrevWorkflow == WorkflowStatus.READY_FOR_PUBLICATION
            || fromConceptPrevWorkflow == WorkflowStatus.PUBLISHED) {
          conceptsToBeApproved.add(relationship.getFrom().getId());
        }

        if (toConceptPrevWorkflow == WorkflowStatus.READY_FOR_PUBLICATION
            || toConceptPrevWorkflow == WorkflowStatus.PUBLISHED) {
          conceptsToBeApproved.add(relationship.getTo().getId());
        }

       updateProgress();

      }
      // confirm that all concepts have been committed
      commitClearBegin();
      
      // approve those concepts that were previously PUBLISHED or READY_FOR_PUBLICATION
      for (Long conceptId : conceptsToBeApproved) {
        Concept refreshedConcept = getConcept(conceptId);
        approveAction = new ApproveMolecularAction();
        approveAction.setProject(getProject());
        approveAction.setActivityId(getActivityId());
        approveAction.setConceptId(refreshedConcept.getId());
        approveAction.setConceptId2(null);
        approveAction.setLastModifiedBy(getLastModifiedBy());
        approveAction
            .setLastModified(refreshedConcept.getLastModified().getTime());
        approveAction.setOverrideWarnings(true);
        approveAction.setTransactionPerOperation(false);
        approveAction.setMolecularActionFlag(true);
        approveAction.setChangeStatusFlag(true);

        // Perform the approveAction
        ValidationResult approveValidationResult =
            approveAction.performMolecularAction(approveAction,
                getLastModifiedBy(), true, false);
        approveAction.close();

        // If the approveAction failed, bail out now.
        if (!approveValidationResult.isValid()) {
          logError("  unable to approve " + refreshedConcept.getId());
          for (final String error : approveValidationResult.getErrors()) {
            logError("    error = " + error);
          }
        }
        
        commitClearBegin();
      }

      logInfo("Finished " + getName());
      
    } catch (Exception e) {
      e.printStackTrace();
      fail("Unexpected exception thrown - please review stack trace.");
    } finally {
      action.close();
      approveAction.close();
    }

  }

  private boolean noXRRel(Concept a, Concept b) {
    for (ConceptRelationship cr : a.getRelationships()) {
      if (cr.getRelationshipType().equals("XR") && (cr.getFrom().getId() == b.getId() || cr.getTo().getId() == b.getId())) {
          System.out.println("found XR rel: " + a.getId() + " " + b.getId());
          return false;
      }
    }
    return true;
  }
  
  /* see superclass */
  @Override
  public void reset() throws Exception {
    logInfo("Starting RESET " + getName());
    // n/a - No reset
    logInfo("Finished RESET " + getName());
  }

  /* see superclass */
  @Override
  public void checkProperties(Properties p) throws Exception {
    // n/a
  }

  /* see superclass */
  @Override
  public void setProperties(Properties p) throws Exception {
    // n/a
  }

  /* see superclass */
  @Override
  public List<AlgorithmParameter> getParameters() throws Exception {
    final List<AlgorithmParameter> params = super.getParameters();

    return params;
  }

  @Override
  public String getDescription() {
    return "Bequeaths deleted cuis to their closest published ancestor";
  }

}